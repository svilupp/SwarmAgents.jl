var documenterSearchIndex = {"docs":
[{"location":"api/","page":"API","title":"API","text":"CurrentModule = SwarmAgents","category":"page"},{"location":"api/#API-Reference","page":"API","title":"API Reference","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"API Reference for SwarmAgents.","category":"page"},{"location":"api/","page":"API","title":"API","text":"","category":"page"},{"location":"api/","page":"API","title":"API","text":"Modules = [SwarmAgents]","category":"page"},{"location":"api/#SwarmAgents.AbstractAgent","page":"API","title":"SwarmAgents.AbstractAgent","text":"AbstractAgent\n\nBase abstract type for all agents in the system. Agents can be either concrete actors that perform actions or references to other agents.\n\n\n\n\n\n","category":"type"},{"location":"api/#SwarmAgents.AbstractAgentActor","page":"API","title":"SwarmAgents.AbstractAgentActor","text":"AbstractAgentActor <: AbstractAgent\n\nAbstract type for concrete agent implementations that can perform actions. These are the actual agents that execute tasks and interact with tools.\n\n\n\n\n\n","category":"type"},{"location":"api/#SwarmAgents.AbstractAgentRef","page":"API","title":"SwarmAgents.AbstractAgentRef","text":"AbstractAgentRef <: AbstractAgent\n\nAbstract type for agent references that point to other agents. Used to create indirect references and chains of agent responsibilities.\n\n\n\n\n\n","category":"type"},{"location":"api/#SwarmAgents.AbstractFlowRules","page":"API","title":"SwarmAgents.AbstractFlowRules","text":"Abstract type hierarchy for flow rules in SwarmAgents.\n\nNotes\n\nFlow rules, including tool flow rules and termination checks, ignore PrivateMessage visibility\nThey operate on the underlying messages regardless of privacy settings\n\n\n\n\n\n","category":"type"},{"location":"api/#SwarmAgents.AbstractTerminationFlowRules","page":"API","title":"SwarmAgents.AbstractTerminationFlowRules","text":"AbstractTerminationFlowRules <: AbstractFlowRules\n\nAbstract type for rules that determine when to terminate agent execution. These rules prevent infinite loops and detect completion conditions.\n\n\n\n\n\n","category":"type"},{"location":"api/#SwarmAgents.AbstractToolFlowRules","page":"API","title":"SwarmAgents.AbstractToolFlowRules","text":"AbstractToolFlowRules <: AbstractFlowRules\n\nAbstract type for rules that govern tool usage and selection. These rules determine which tools can be used and in what order.\n\n\n\n\n\n","category":"type"},{"location":"api/#SwarmAgents.Agent","page":"API","title":"SwarmAgents.Agent","text":"Agent <: AbstractAgentActor\n\nA concrete agent implementation that can perform actions.\n\nFields\n\nname::String: The name of the agent\nmodel::String: The model to use for the agent\ninstructions::String: The instructions for the agent\ntool_map::Dict{String, AbstractTool}: A dictionary of tools available to the agent\ntool_choice::Union{String, Nothing}: The tool choice for the agent\nparallel_tool_calls::Bool: Whether to allow parallel tool calls\nprivate::Bool: Whether agent's messages should be private by default\n\n\n\n\n\n","category":"type"},{"location":"api/#SwarmAgents.AgentRef","page":"API","title":"SwarmAgents.AgentRef","text":"AgentRef <: AbstractAgentRef\n\nA reference to another agent in the system.\n\nFields\n\nname::String: The name of the referenced agent\n\n\n\n\n\n","category":"type"},{"location":"api/#SwarmAgents.FixedOrder","page":"API","title":"SwarmAgents.FixedOrder","text":"FixedOrder <: AbstractToolFlowRules\n\nEnforces a fixed order of tool execution.\n\nFields\n\nname::String: Name of the rule\norder::Vector{Symbol}: List of tools in required execution order\n\nExamples\n\n# Create with keyword constructor\nrule = FixedOrder(order=[:tool1, :tool2, :tool3])\n\nNotes\n\nOnly allows one tool at a time in strict sequence\nReturns empty list when all tools have been used\n\n\n\n\n\n","category":"type"},{"location":"api/#SwarmAgents.FixedPrerequisites","page":"API","title":"SwarmAgents.FixedPrerequisites","text":"FixedPrerequisites <: AbstractToolFlowRules\n\nEnforces prerequisites for tool execution.\n\nFields\n\nname::String: Name of the rule\nprerequisites::Dict{Symbol,Vector{Symbol}}: Map of tools to their prerequisites\n\nExamples\n\n# Create with keyword constructor and ordered list\nrule = FixedPrerequisites(order=[:tool1, :tool2, :tool3])\n\n# Create with explicit prerequisites\nprereqs = Dict(:tool2 => [:tool1], :tool3 => [:tool1, :tool2])\nrule = FixedPrerequisites(prerequisites=prereqs)\n\nNotes\n\nTools can only be used after their prerequisites\nTools without prerequisites are always allowed\n\n\n\n\n\n","category":"type"},{"location":"api/#SwarmAgents.PrivateMessage","page":"API","title":"SwarmAgents.PrivateMessage","text":"PrivateMessage <: PT.AbstractMessage\n\nA wrapper message type that defines message visibility for agents.\n\nMessage Visibility Rules:\n\nMessages from private agents are wrapped in PrivateMessage\nMessages are made public (visible to all agents) in the following cases:\nLast turn of an agent's sequence (marked with last_turn=true)\nAssistant messages with no tool calls (to explain why tool calls stopped)\nMessages from agent handoff (when a new agent is selected)\nOnly intermediate tool calls remain private\n\nThis ensures that following agents understand why they were called while maintaining privacy of intermediate processing steps.\n\nFields\n\nobject::PT.AbstractMessage: The underlying message being wrapped\nvisible::Vector{String}: List of agent names that can see this message\nlast_turn::Bool: Indicates if this message is from the last turn of an agent\n\n\n\n\n\n","category":"type"},{"location":"api/#SwarmAgents.Response","page":"API","title":"SwarmAgents.Response","text":"Response\n\nContainer for the results of a workflow operation.\n\nFields\n\nmessages::Vector{<:PT.AbstractMessage}: New messages generated during the operation\nagent::Union{AbstractAgent, Nothing}: The resulting agent state\ncontext::Dict{Symbol, Any}: The resulting context state\n\n\n\n\n\n","category":"type"},{"location":"api/#SwarmAgents.Session","page":"API","title":"SwarmAgents.Session","text":"Session\n\nMain container for managing agent interactions and state.\n\nFields\n\nmessages::Vector{<:PT.AbstractMessage}: Message history\nagent::Union{AbstractAgent, Nothing}: Currently active agent\ncontext::Dict{Symbol, Any}: Context variables\nartifacts::Vector{Any}: Tool outputs\nio::Union{Nothing,IO}: Output stream\nrules::Dict{String, AbstractFlowRules}: Session rules\nagent_map::Dict{Symbol, <:AbstractAgent}: Agent reference map\n\n\n\n\n\n","category":"type"},{"location":"api/#SwarmAgents.TerminationCycleCheck","page":"API","title":"SwarmAgents.TerminationCycleCheck","text":"TerminationCycleCheck(n_cycles::Int=3, span::Int=3)\n\nChecks for repeated cycles of tool calls in the message history.\n\nFields\n\nn_cycles::Int=3: Number of cycles required to trigger termination\nspan::Int=3: Maximum width of cycle to be considered\n\nNotes\n\nIgnores PrivateMessage visibility, operates on all messages\nIgnores AIToolRequests and non-tool messages\n\nExample\n\n# Check for 3 repetitions of cycles up to length 3\nrule = TerminationCycleCheck(3, 3)\n\n\n\n\n\n","category":"type"},{"location":"api/#SwarmAgents.TerminationGenericCheck","page":"API","title":"SwarmAgents.TerminationGenericCheck","text":"TerminationGenericCheck\n\nCustom termination check using a provided function.\n\nFields\n\ncallable::Function: Function that takes (history, activeagent) and returns activeagent\n\nNotes\n\nIgnores PrivateMessage visibility by default, but custom function can implement visibility checks\nFunction should return nothing to trigger termination\n\nExample\n\n# Create with a function (both styles work)\ncheck = TerminationGenericCheck((history, agent) -> length(history) > 10 ? nothing : agent)\ncheck = TerminationGenericCheck(callable=(history, agent) -> length(history) > 10 ? nothing : agent)\n\n\n\n\n\n","category":"type"},{"location":"api/#SwarmAgents.TerminationRepeatCheck","page":"API","title":"SwarmAgents.TerminationRepeatCheck","text":"TerminationRepeatCheck(n::Int)\n\nChecks for consecutive repetitions of the same tool.\n\nFields\n\nn::Int: Number of consecutive repeats required to trigger termination\n\nNotes\n\nIgnores PrivateMessage visibility, operates on all messages\nIgnores AIToolRequests and non-tool messages\n\nExample\n\n# Terminate if same tool is used 5 times in a row\nrule = TerminationRepeatCheck(5)\n\n\n\n\n\n","category":"type"},{"location":"api/#SwarmAgents.ToolFlowRules","page":"API","title":"SwarmAgents.ToolFlowRules","text":"ToolFlowRules <: AbstractToolFlowRules\n\nA concrete implementation of tool flow rules that manages a single tool.\n\nFields\n\nname::String: Name of the rule (defaults to tool's name)\ntool::Tool: The tool this rule manages\n\nExamples\n\nrule = ToolFlowRules(Tool(my_function))\n\n\n\n\n\n","category":"type"},{"location":"api/#SwarmAgents.add_rules!-Tuple{Session, AbstractFlowRules}","page":"API","title":"SwarmAgents.add_rules!","text":"add_rules!(session::Session, rule::AbstractFlowRules)\n\nAdd a single flow rule to a session.\n\nArguments\n\nsession::Session: The session to add the rule to\nrule::AbstractFlowRules: Rule to add\n\nNotes\n\nRule is added to session.rules\nDuplicate rule names will be overwritten with a warning\n\n\n\n\n\n","category":"method"},{"location":"api/#SwarmAgents.add_rules!-Tuple{Session, Vector{<:AbstractFlowRules}}","page":"API","title":"SwarmAgents.add_rules!","text":"add_rules!(session::Session, rules::Vector{<:AbstractFlowRules})\n\nAdd flow rules to a session.\n\nArguments\n\nsession::Session: The session to add rules to\nrules::Vector{<:AbstractFlowRules}: Vector of rules to add\n\nNotes\n\nRules are added to session.rules\nDuplicate rule names will be overwritten with a warning\n\n\n\n\n\n","category":"method"},{"location":"api/#SwarmAgents.add_tools!-Tuple{Agent, Vector}","page":"API","title":"SwarmAgents.add_tools!","text":"add_tools!(agent::Agent, tools::Vector)\n\nAdds tools to an agent.\n\n\n\n\n\n","category":"method"},{"location":"api/#SwarmAgents.convert_message-Tuple{Type{<:PromptingTools.AbstractMessage}, PromptingTools.AbstractMessage}","page":"API","title":"SwarmAgents.convert_message","text":"convert_message(T::Type{<:PT.AbstractMessage}, msg::PT.AbstractMessage)\n\nConvert a message to the specified message type.\n\n\n\n\n\n","category":"method"},{"location":"api/#SwarmAgents.filter_history-Tuple{AbstractVector{<:PromptingTools.AbstractMessage}, Agent}","page":"API","title":"SwarmAgents.filter_history","text":"filter_history(history::AbstractVector{<:PT.AbstractMessage}, agent::Agent)\n\nFilter message history to only include messages visible to the specified agent.\n\n\n\n\n\n","category":"method"},{"location":"api/#SwarmAgents.get_used_tools","page":"API","title":"SwarmAgents.get_used_tools","text":"get_used_tools(history::AbstractVector{<:PT.AbstractMessage}, agent::Union{AbstractAgent,Nothing}=nothing)\n\nGet a list of all tools used in the message history, regardless of message privacy settings. Privacy settings do not affect tool usage tracking as this is essential for flow control and authentication state management.\n\nArguments\n\nhistory::AbstractVector{<:PT.AbstractMessage}: The message history to analyze\nagent::Union{AbstractAgent,Nothing}=nothing: Optional agent (kept for API compatibility)\n\nReturns\n\nVector{Symbol}: List of all tool names used in the message history\n\nNotes\n\nIgnores PrivateMessage visibility, operates on underlying messages\nEssential for flow control and authentication state management\n\n\n\n\n\n","category":"function"},{"location":"api/#SwarmAgents.handle_tool_calls!-Tuple{Union{Nothing, Agent}, AbstractVector{<:PromptingTools.AbstractMessage}, Session}","page":"API","title":"SwarmAgents.handle_tool_calls!","text":"handle_tool_calls!(active_agent::Union{Agent, Nothing}, history::AbstractVector{<:PT.AbstractMessage}, session::Session)\n\nHandle tool calls for an agent.\n\n\n\n\n\n","category":"method"},{"location":"api/#SwarmAgents.is_cycle-Tuple{Any}","page":"API","title":"SwarmAgents.is_cycle","text":"is_cycle(history; n::Int, span::Int)\n\nCheck if there has been a repeated cycle of tool calls.\n\nArguments\n\nhistory: Vector of messages\nn::Int: Number of cycles required\nspan::Int: Maximum width of cycle to consider\n\nReturns\n\nBool: true if a cycle is detected\n\nNotes\n\nIgnores PrivateMessage visibility, operates on underlying messages\nIgnores AIToolRequests and non-tool messages\n\n\n\n\n\n","category":"method"},{"location":"api/#SwarmAgents.is_visible-Tuple{PromptingTools.AbstractMessage, Agent}","page":"API","title":"SwarmAgents.is_visible","text":"is_visible(message::PT.AbstractMessage, agent::Agent)::Bool\n\nDetermine if a message is visible to a specific agent. Returns true for non-private messages, and checks visibility list for private messages.\n\n\n\n\n\n","category":"method"},{"location":"api/#SwarmAgents.isabstractagent-Tuple{AbstractAgent}","page":"API","title":"SwarmAgents.isabstractagent","text":"isabstractagent(x)\n\nCheck if x is an AbstractAgent.\n\n\n\n\n\n","category":"method"},{"location":"api/#SwarmAgents.isabstractagentactor-Tuple{AbstractAgent}","page":"API","title":"SwarmAgents.isabstractagentactor","text":"isabstractagentactor(x)\n\nCheck if x is an AbstractAgentActor.\n\n\n\n\n\n","category":"method"},{"location":"api/#SwarmAgents.isabstractagentref-Tuple{AbstractAgent}","page":"API","title":"SwarmAgents.isabstractagentref","text":"isabstractagentref(x)\n\nCheck if x is an AbstractAgentRef.\n\n\n\n\n\n","category":"method"},{"location":"api/#SwarmAgents.num_subsequent_repeats-Tuple{Any}","page":"API","title":"SwarmAgents.num_subsequent_repeats","text":"num_subsequent_repeats(history)\n\nCount maximum number of subsequent repeats of any tool.\n\nArguments\n\nhistory: Vector of messages\n\nReturns\n\nInt: Maximum number of subsequent repeats\n\nNotes\n\nIgnores PrivateMessage visibility, operates on underlying messages\nIgnores AIToolRequests and non-tool messages\n\n\n\n\n\n","category":"method"},{"location":"api/#SwarmAgents.print_progress-Tuple{Union{Nothing, IO}, Union{Nothing, AbstractAgent}, Any}","page":"API","title":"SwarmAgents.print_progress","text":"print_progress(io::Union{IO, Nothing}, agent::Union{AbstractAgent, Nothing}, msg::AbstractMessage)\n\nPrint progress messages for agent actions.\n\n\n\n\n\n","category":"method"},{"location":"api/#SwarmAgents.run_full_turn!-Tuple{Session, AbstractString}","page":"API","title":"SwarmAgents.run_full_turn!","text":"run_full_turn!(session::Session, user_prompt::AbstractString; kwargs...)\n\nRun a full turn with a user prompt, updating the session state.\n\n\n\n\n\n","category":"method"},{"location":"api/#SwarmAgents.run_full_turn-Tuple{AbstractAgent, AbstractVector{<:PromptingTools.AbstractMessage}, Session}","page":"API","title":"SwarmAgents.run_full_turn","text":"run_full_turn(agent::AbstractAgent, messages::AbstractVector{<:PT.AbstractMessage}, session::Session; max_turns::Int = 5)\n\nRun a full turn of an agent (executes all tool calls).\n\n\n\n\n\n","category":"method"},{"location":"api/#SwarmAgents.run_termination_checks-NTuple{4, Any}","page":"API","title":"SwarmAgents.run_termination_checks","text":"run_termination_checks(history, active_agent, io, checks)\n\nRun all termination checks on the message history.\n\nArguments\n\nhistory: Vector of messages\nactive_agent: Current active agent\nio: IO stream for printing messages\nchecks: Vector of termination checks\n\nReturns\n\nUnion{AbstractAgent, Nothing}: Updated active agent (nothing if terminated)\n\nNotes\n\nIgnores PrivateMessage visibility for all checks\nPrints termination messages to io when triggered\n\n\n\n\n\n","category":"method"},{"location":"api/#SwarmAgents.scrub_agent_name-Tuple{AbstractAgent}","page":"API","title":"SwarmAgents.scrub_agent_name","text":"scrub_agent_name(agent::AbstractAgent)\n\nClean up agent name for display.\n\n\n\n\n\n","category":"method"},{"location":"api/#SwarmAgents.update_system_message!-Union{Tuple{T}, Tuple{AbstractVector{T}, Union{Nothing, Agent}}} where T<:PromptingTools.AbstractMessage","page":"API","title":"SwarmAgents.update_system_message!","text":"update_system_message!(history::AbstractVector{<:PT.AbstractMessage}, active_agent::Union{Agent, Nothing})\n\nUpdate the system message in the history with the active agent's instructions.\n\n\n\n\n\n","category":"method"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = SwarmAgents","category":"page"},{"location":"#SwarmAgents.jl","page":"Home","title":"SwarmAgents.jl","text":"","category":"section"},{"location":"#Experimental-Package","page":"Home","title":"⚠️ Experimental Package ⚠️","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"WARNING: SwarmAgents.jl is currently in an experimental stage and is under active development. Features, APIs, and functionalities may change without notice. Use at your own risk.","category":"page"},{"location":"#Overview","page":"Home","title":"Overview","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"SwarmAgents.jl is a very opinionated translation of OpenAI's Swarm package. This Julia implementation leverages PromptingTools.jl to enable support for multiple LLM providers and tool calling functionalities.","category":"page"},{"location":"#Key-Features","page":"Home","title":"Key Features","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Integration with various LLM providers through PromptingTools.jl.\nEnhanced tool calling capabilities.\nA flexible and extensible framework for Multi-Agent systems.","category":"page"},{"location":"#Getting-Started","page":"Home","title":"Getting Started","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"You need to have API keys for a supported LLM provider (eg, OPENAI_API_KEY in your environment variables). See PromptingTools.jl for more details.\nInstall the package:","category":"page"},{"location":"","page":"Home","title":"Home","text":"using Pkg\nPkg.add(; url = \"https://github.com/svilupp/SwarmAgents.jl\")","category":"page"},{"location":"#Key-Concepts","page":"Home","title":"Key Concepts","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This implementation mostly follows the OpenAI Swarm package. It might be helpful to read the original cookbook on orchestrating agents.","category":"page"},{"location":"#Routines","page":"Home","title":"Routines","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"A routine is a set of instructions for an AI agent to follow, like a recipe.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Example: A customer service routine","category":"page"},{"location":"","page":"Home","title":"Home","text":"Understand the problem\nSuggest a solution or transfer to a specialized agent\nOffer a refund if needed","category":"page"},{"location":"#Handoffs","page":"Home","title":"Handoffs","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"A handoff occurs when one AI agent passes the conversation to another specialized agent.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Example: Customer support system","category":"page"},{"location":"","page":"Home","title":"Home","text":"Triage Agent → directs to appropriate department\nSales Agent ← handles purchases\nRepair Agent ← manages product issues","category":"page"},{"location":"","page":"Home","title":"Home","text":"Handoffs allow seamless transitions between different expertise areas, enhancing the overall interaction.","category":"page"},{"location":"#Usage","page":"Home","title":"Usage","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"using Swarm\n\n## Define agents and their tools\n# Instructions are the routines\nenglish_agent = Agent(name = \"English Agent\",\n    instructions = \"You only speak English.\")\nspanish_agent = Agent(name = \"Spanish Agent\",\n    instructions = \"You only speak Spanish.\")\n\n# Below are the handoffs\ntransfer_to_spanish_agent() = spanish_agent\nadd_tools!(english_agent, transfer_to_spanish_agent)\n\ntransfer_to_english_agent() = english_agent\nadd_tools!(spanish_agent, transfer_to_english_agent)\n\n# Initialize a session to hold the state and pick the initial agent\nsess = Session(english_agent)\n\n# Run a full turn until tools are depleted\nrun_full_turn!(sess, \"Hola. ¿Como estás?\")\n\n# You can run repeated turns to continue the session\nrun_full_turn!(sess, \"What do you mean?\")","category":"page"},{"location":"","page":"Home","title":"Home","text":">> User: Hola. ¿Como estás?\n\n>> Tool Request: transfer_to_spanish_agent, args: Dict{Symbol, Any}()\n>> Tool Output: {\"assistant\":\"Spanish Agent\"}\n>> Assistant: ¡Hola! Estoy bien, gracias. ¿Y tú?\n\n>> User: What do you mean?\n\n>> Tool Request: transfer_to_english_agent, args: Dict{Symbol, Any}()\n>> Tool Output: {\"assistant\":\"English Agent\"}\n>> Assistant: You were speaking in Spanish, so I transferred you to a Spanish-speaking agent. How can I assist you in English today?","category":"page"},{"location":"","page":"Home","title":"Home","text":"See folder examples/ for more examples.","category":"page"}]
}
