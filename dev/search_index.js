var documenterSearchIndex = {"docs":
[{"location":"api/","page":"API","title":"API","text":"CurrentModule = SwarmAgents","category":"page"},{"location":"api/#API-Reference","page":"API","title":"API Reference","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"API Reference for SwarmAgents.","category":"page"},{"location":"api/","page":"API","title":"API","text":"","category":"page"},{"location":"api/","page":"API","title":"API","text":"Modules = [SwarmAgents]","category":"page"},{"location":"api/#SwarmAgents.AbstractAgent","page":"API","title":"SwarmAgents.AbstractAgent","text":"AbstractAgent\n\nBase abstract type for all agents in the system. Agents can be either concrete actors that perform actions or references to other agents.\n\n\n\n\n\n","category":"type"},{"location":"api/#SwarmAgents.AbstractAgentActor","page":"API","title":"SwarmAgents.AbstractAgentActor","text":"AbstractAgentActor <: AbstractAgent\n\nAbstract type for concrete agent implementations that can perform actions. These are the actual agents that execute tasks and interact with tools.\n\n\n\n\n\n","category":"type"},{"location":"api/#SwarmAgents.AbstractAgentRef","page":"API","title":"SwarmAgents.AbstractAgentRef","text":"AbstractAgentRef <: AbstractAgent\n\nAbstract type for agent references that point to other agents. Used to create indirect references and chains of agent responsibilities.\n\n\n\n\n\n","category":"type"},{"location":"api/#SwarmAgents.AbstractFlowRules","page":"API","title":"SwarmAgents.AbstractFlowRules","text":"AbstractFlowRules\n\nBase abstract type for all flow control rules in the system. Flow rules govern how agents interact and how the system progresses.\n\n\n\n\n\n","category":"type"},{"location":"api/#SwarmAgents.AbstractTerminationFlowRules","page":"API","title":"SwarmAgents.AbstractTerminationFlowRules","text":"AbstractTerminationFlowRules <: AbstractFlowRules\n\nAbstract type for rules that determine when to terminate agent execution. These rules prevent infinite loops and detect completion conditions.\n\n\n\n\n\n","category":"type"},{"location":"api/#SwarmAgents.AbstractToolFlowRules","page":"API","title":"SwarmAgents.AbstractToolFlowRules","text":"AbstractToolFlowRules <: AbstractFlowRules\n\nAbstract type for rules that control tool execution and flow. These rules determine which tools are allowed to be used at any given point.\n\n\n\n\n\n","category":"type"},{"location":"api/#SwarmAgents.Agent","page":"API","title":"SwarmAgents.Agent","text":"Agent <: AbstractAgentActor\n\nA concrete agent implementation that can perform actions.\n\nFields\n\nname::String: The name of the agent\nmodel::String: The model to use for the agent\ninstructions::String: The instructions for the agent\ntool_map::Dict{String, AbstractTool}: A dictionary of tools available to the agent\ntool_choice::Union{String, Nothing}: The tool choice for the agent\nparallel_tool_calls::Bool: Whether to allow parallel tool calls\nprivate::Bool: Whether agent's messages should be private by default\n\n\n\n\n\n","category":"type"},{"location":"api/#SwarmAgents.AgentRef","page":"API","title":"SwarmAgents.AgentRef","text":"AgentRef <: AbstractAgentRef\n\nA reference to another agent in the system.\n\nFields\n\nname::String: The name of the referenced agent\n\n\n\n\n\n","category":"type"},{"location":"api/#SwarmAgents.FixedOrder","page":"API","title":"SwarmAgents.FixedOrder","text":"FixedOrder <: AbstractToolFlowRules\n\nA concrete implementation of AbstractToolFlowRules that enforces a fixed order of tool execution. Controls tool availability based on execution sequence.\n\nFields\n\nname::String: Name of the rule\norder::Vector{String}: List of tools in required execution order\n\nExamples\n\n# Single tool (always available as first in cycle)\nrule = FixedOrder(tool)  # Convenience constructor for single tool\n\n# Multiple tools in sequence\ntools = [tool1, tool2, tool3]\nrules = [FixedOrder(tool) for tool in tools]  # Broadcast FixedOrder over tools\nadd_rules!(session, rules)  # Add as flow rules\n\n# Create with explicit order\nrule = FixedOrder([\"tool1\", \"tool2\", \"tool3\"])\n\nNotes\n\nOnly allows one tool at a time in strict sequence\nReturns empty list when all tools have been used\nIf order is empty, returns all_tools (passthrough)\nSingle tool constructor makes the tool always available (first in cycle)\n\n\n\n\n\n","category":"type"},{"location":"api/#SwarmAgents.FixedPrerequisites","page":"API","title":"SwarmAgents.FixedPrerequisites","text":"FixedPrerequisites <: AbstractToolFlowRules\n\nA concrete implementation of AbstractToolFlowRules that enforces prerequisites for tool execution. Controls tool availability based on prerequisite completion.\n\nFields\n\nname::String: Name of the rule\nprerequisites::Dict{String,Vector{String}}: Map of tools to their prerequisites\n\nExamples\n\n# Create with keyword constructor and ordered list\nrule = FixedPrerequisites(order=[\"search\", \"analyze\", \"summarize\"])\n\n# Create with explicit prerequisites\nprereqs = Dict(\"analyze\" => [\"search\"], \"summarize\" => [\"search\", \"analyze\"])\nrule = FixedPrerequisites(prerequisites=prereqs)\n\nNotes\n\nTools can only be used after their prerequisites\nTools without prerequisites are always allowed\n\n\n\n\n\n","category":"type"},{"location":"api/#SwarmAgents.PrivateMessage","page":"API","title":"SwarmAgents.PrivateMessage","text":"PrivateMessage <: PT.AbstractMessage\n\nA wrapper message type that defines message visibility for agents.\n\nMessage Visibility Rules:\n\nMessages from private agents are wrapped in PrivateMessage\nMessages are made public (visible to all agents) in the following cases:\nLast turn of an agent's sequence (marked with last_turn=true)\nAssistant messages with no tool calls (to explain why tool calls stopped)\nMessages from agent handoff (when a new agent is selected)\nOnly intermediate tool calls remain private\n\nThis ensures that following agents understand why they were called while maintaining privacy of intermediate processing steps.\n\nFields\n\nobject::PT.AbstractMessage: The underlying message being wrapped\nvisible::Vector{String}: List of agent names that can see this message\nlast_turn::Bool: Indicates if this message is from the last turn of an agent\n\n\n\n\n\n","category":"type"},{"location":"api/#SwarmAgents.Response","page":"API","title":"SwarmAgents.Response","text":"Response\n\nContainer for the results of a workflow operation.\n\nFields\n\nmessages::Vector{<:PT.AbstractMessage}: New messages generated during the operation\nagent::Union{AbstractAgent, Nothing}: The resulting agent state\ncontext::Dict{Symbol, Any}: The resulting context state\ntools_used::Vector{AbstractTool}: Tools used during the operation\n\n\n\n\n\n","category":"type"},{"location":"api/#SwarmAgents.Session","page":"API","title":"SwarmAgents.Session","text":"Session\n\nMain container for managing agent interactions and state.\n\nFields\n\nmessages::Vector{<:PT.AbstractMessage}: Message history\nagent::Union{AbstractAgent, Nothing}: Currently active agent\ncontext::Dict{Symbol, Any}: Context variables\nartifacts::Vector{Any}: Tool outputs\nio::Union{Nothing,IO}: Output stream\nrules::Vector{AbstractFlowRules}: Session rules\nagent_map::Dict{Symbol, <:AbstractAgent}: Agent reference map\n\n\n\n\n\n","category":"type"},{"location":"api/#SwarmAgents.TerminationCycleCheck","page":"API","title":"SwarmAgents.TerminationCycleCheck","text":"TerminationCycleCheck(n_cycles::Int=3, span::Int=3)\n\nChecks for repeated cycles of tool calls in the message history.\n\nFields\n\nn_cycles::Int=3: Number of cycles required to trigger termination\nspan::Int=3: Maximum width of cycle to be considered\n\nNotes\n\nIgnores PrivateMessage visibility, operates on all messages\nIgnores AIToolRequests and non-tool messages\n\nExample\n\n# Check for 3 repetitions of cycles up to length 3\nrule = TerminationCycleCheck(3, 3)\n\n\n\n\n\n","category":"type"},{"location":"api/#SwarmAgents.TerminationGenericCheck","page":"API","title":"SwarmAgents.TerminationGenericCheck","text":"TerminationGenericCheck\n\nCustom termination check using a provided function.\n\nFields\n\ncallable::Function: Function that takes (history, activeagent) and returns activeagent\n\nNotes\n\nIgnores PrivateMessage visibility by default, but custom function can implement visibility checks\nFunction should return nothing to trigger termination\n\nExample\n\n# Create with a function (both styles work)\ncheck = TerminationGenericCheck((history, agent) -> length(history) > 10 ? nothing : agent)\ncheck = TerminationGenericCheck(callable=(history, agent) -> length(history) > 10 ? nothing : agent)\n\n\n\n\n\n","category":"type"},{"location":"api/#SwarmAgents.TerminationRepeatCheck","page":"API","title":"SwarmAgents.TerminationRepeatCheck","text":"TerminationRepeatCheck(n::Int)\n\nChecks for consecutive repetitions of the same tool.\n\nFields\n\nn::Int: Number of consecutive repeats required to trigger termination\n\nNotes\n\nIgnores PrivateMessage visibility, operates on all messages\nIgnores AIToolRequests and non-tool messages\n\nExample\n\n# Terminate if same tool is used 5 times in a row\nrule = TerminationRepeatCheck(5)\n\n\n\n\n\n","category":"type"},{"location":"api/#SwarmAgents.add_rules!-Tuple{Session, AbstractFlowRules}","page":"API","title":"SwarmAgents.add_rules!","text":"add_rules!(session::Session, rule::AbstractFlowRules)\n\nAdd a single flow rule to a session.\n\nArguments\n\nsession::Session: The session to add the rule to\nrule::AbstractFlowRules: Rule to add\n\nNotes\n\nRule is added to session.rules vector\n\n\n\n\n\n","category":"method"},{"location":"api/#SwarmAgents.add_rules!-Tuple{Session, Vector{<:AbstractFlowRules}}","page":"API","title":"SwarmAgents.add_rules!","text":"add_rules!(session::Session, rules::Vector{<:AbstractFlowRules})\n\nAdd flow rules to a session.\n\nArguments\n\nsession::Session: The session to add rules to\nrules::Vector{<:AbstractFlowRules}: Vector of rules to add\n\nNotes\n\nRules are added to session.rules\nDuplicate rule names will be overwritten with a warning\n\n\n\n\n\n","category":"method"},{"location":"api/#SwarmAgents.add_tools!-Tuple{Agent, Vector}","page":"API","title":"SwarmAgents.add_tools!","text":"add_tools!(agent::Agent, tools::Vector)\n\nAdds tools to an agent.\n\n\n\n\n\n","category":"method"},{"location":"api/#SwarmAgents.add_transfers!-Tuple{Session}","page":"API","title":"SwarmAgents.add_transfers!","text":"add_transfers!(session::Session)\n\nAdd transfer tools to each agent in the session's agent_map to enable transfers between agents. For each agent, creates transfer functions to all other agents (except itself) and adds them as tools.\n\nEach transfer tool includes a handover_message parameter to explain the reason for transfer.\n\nExample:\n\n# If agent_map contains \"Booking Agent\" and \"Support Agent\"\n# Creates tools:\n# - transfer_to_booking_agent(handover_message::String) for Support Agent\n# - transfer_to_support_agent(handover_message::String) for Booking Agent\n\n\n\n\n\n","category":"method"},{"location":"api/#SwarmAgents.convert_message-Tuple{Type{<:PromptingTools.AbstractMessage}, PromptingTools.AbstractMessage}","page":"API","title":"SwarmAgents.convert_message","text":"convert_message(T::Type{<:PT.AbstractMessage}, msg::PT.AbstractMessage)\n\nConvert a message to the specified message type.\n\n\n\n\n\n","category":"method"},{"location":"api/#SwarmAgents.filter_history-Tuple{AbstractVector{<:PromptingTools.AbstractMessage}, Agent}","page":"API","title":"SwarmAgents.filter_history","text":"filter_history(history::AbstractVector{<:PT.AbstractMessage}, agent::Agent)\n\nFilter message history to only include messages visible to the specified agent.\n\n\n\n\n\n","category":"method"},{"location":"api/#SwarmAgents.get_allowed_tools-Tuple{Vector{<:AbstractFlowRules}, Vector{String}, Vector{String}}","page":"API","title":"SwarmAgents.get_allowed_tools","text":"get_allowed_tools(rules::Vector{<:AbstractFlowRules}, used_tools::Vector{String}, all_tools::Vector{String}; combine::Function=union)\n\nGet the list of allowed tools based on flow rules and usage history.\n\nArguments\n\nrules::Vector{<:AbstractFlowRules}: Vector of flow rules to apply\nused_tools::Vector{String}: List of tools that have been used\nall_tools::Vector{String}: Complete set of available tools\ncombine::Function=union: Function to combine results from multiple rules (default: union for OR behavior)\n\nReturns\n\nVector{String}: List of allowed tool names\n\nNotes\n\nOnly processes rules that are subtypes of AbstractToolFlowRules\nIf no tool rules are present, returns all_tools (passthrough)\nEmpty result from a rule means no tools allowed by that rule\nResults are combined using union by default (OR behavior)\n\n\n\n\n\n","category":"method"},{"location":"api/#SwarmAgents.get_used_tools","page":"API","title":"SwarmAgents.get_used_tools","text":"get_used_tools(history::AbstractVector{<:PT.AbstractMessage}, agent::Union{AbstractAgent,Nothing}=nothing)\n\nGet a list of all tools used in the message history, regardless of message privacy settings. Privacy settings do not affect tool usage tracking as this is essential for flow control and authentication state management.\n\nArguments\n\nhistory::AbstractVector{<:PT.AbstractMessage}: The message history to analyze\nagent::Union{AbstractAgent,Nothing}=nothing: Optional agent (kept for API compatibility)\n\nReturns\n\nVector{String}: List of all tool names used in the message history\n\nNotes\n\nOnly extracts tool names from AIToolRequest messages' tool_calls\nIgnores PrivateMessage visibility, operates on underlying messages\nEssential for flow control and authentication state management\n\n\n\n\n\n","category":"function"},{"location":"api/#SwarmAgents.handle_tool_calls!-Tuple{Union{Nothing, Agent}, AbstractVector{<:PromptingTools.AbstractMessage}, Session}","page":"API","title":"SwarmAgents.handle_tool_calls!","text":"handle_tool_calls!(active_agent::Union{Agent, Nothing}, history::AbstractVector{<:PT.AbstractMessage}, session::Session)\n\nHandle tool calls for an agent. Tools are executed directly using the agent's tool_map.\n\n\n\n\n\n","category":"method"},{"location":"api/#SwarmAgents.is_cycle-Tuple{Any}","page":"API","title":"SwarmAgents.is_cycle","text":"is_cycle(history; n::Int, span::Int)\n\nCheck if there has been a repeated cycle of tool calls.\n\nArguments\n\nhistory: Vector of messages\nn::Int: Number of cycles required\nspan::Int: Maximum width of cycle to consider\n\nReturns\n\nBool: true if a cycle is detected\n\nNotes\n\nIgnores PrivateMessage visibility, operates on underlying messages\nIgnores AIToolRequests and non-tool messages\n\n\n\n\n\n","category":"method"},{"location":"api/#SwarmAgents.is_visible-Tuple{PromptingTools.AbstractMessage, Agent}","page":"API","title":"SwarmAgents.is_visible","text":"is_visible(message::PT.AbstractMessage, agent::Agent)::Bool\n\nDetermine if a message is visible to a specific agent. Returns true for non-private messages, and checks visibility list for private messages.\n\n\n\n\n\n","category":"method"},{"location":"api/#SwarmAgents.isabstractagent-Tuple{AbstractAgent}","page":"API","title":"SwarmAgents.isabstractagent","text":"isabstractagent(x)\n\nCheck if x is an AbstractAgent.\n\n\n\n\n\n","category":"method"},{"location":"api/#SwarmAgents.isabstractagentactor-Tuple{AbstractAgent}","page":"API","title":"SwarmAgents.isabstractagentactor","text":"isabstractagentactor(x)\n\nCheck if x is an AbstractAgentActor.\n\n\n\n\n\n","category":"method"},{"location":"api/#SwarmAgents.isabstractagentref-Tuple{AbstractAgent}","page":"API","title":"SwarmAgents.isabstractagentref","text":"isabstractagentref(x)\n\nCheck if x is an AbstractAgentRef.\n\n\n\n\n\n","category":"method"},{"location":"api/#SwarmAgents.num_subsequent_repeats-Tuple{Any}","page":"API","title":"SwarmAgents.num_subsequent_repeats","text":"num_subsequent_repeats(history)\n\nCount maximum number of subsequent repeats of any tool.\n\nArguments\n\nhistory: Vector of messages\n\nReturns\n\nInt: Maximum number of subsequent repeats\n\nNotes\n\nIgnores PrivateMessage visibility, operates on underlying messages\nIgnores AIToolRequests and non-tool messages\n\n\n\n\n\n","category":"method"},{"location":"api/#SwarmAgents.print_progress-Tuple{Union{Nothing, IO}, Union{Nothing, AbstractAgent}, Any}","page":"API","title":"SwarmAgents.print_progress","text":"print_progress(io::Union{IO, Nothing}, agent::Union{AbstractAgent, Nothing}, msg::AbstractMessage)\n\nPrint progress messages for agent actions.\n\n\n\n\n\n","category":"method"},{"location":"api/#SwarmAgents.run_full_turn!-Tuple{Session, AbstractString}","page":"API","title":"SwarmAgents.run_full_turn!","text":"run_full_turn!(session::Session, user_prompt::AbstractString; kwargs...)\n\nRun a full turn with a user prompt, updating the session state.\n\n\n\n\n\n","category":"method"},{"location":"api/#SwarmAgents.run_full_turn-Tuple{AbstractAgent, AbstractVector{<:PromptingTools.AbstractMessage}, Session}","page":"API","title":"SwarmAgents.run_full_turn","text":"run_full_turn(agent::AbstractAgent, messages::AbstractVector{<:PT.AbstractMessage}, session::Session; max_turns::Int = 5, combine::Function = vcat)\n\nRun a full turn of an agent, executing all tool calls with proper tool filtering and termination checks.\n\nArguments\n\nagent::AbstractAgent: The agent to run the turn for\nmessages::AbstractVector{<:PT.AbstractMessage}: Initial message history\nsession::Session: Session containing rules and context\nmax_turns::Int = 5: Maximum number of turns to execute\ncombine::Function = vcat: Function to combine results from multiple tool rules (must use vcat for multiple tools)\n\nNotes\n\nTools are filtered using getallowedtools based on session rules\nAvailable tools come from agent's tool_map\nIf no tool rules exist, all agent tools are available\nTool selection respects AbstractToolFlowRules filtering\nFor single tool usage, wrap tool in FixedOrder: FixedOrder(tool)\nFor multiple tools, use vcat as combine function to merge tool lists\nTermination checks are run after each tool execution\n\n\n\n\n\n","category":"method"},{"location":"api/#SwarmAgents.run_termination_checks-NTuple{4, Any}","page":"API","title":"SwarmAgents.run_termination_checks","text":"run_termination_checks(history, active_agent, io, checks)\n\nRun all termination checks on the message history.\n\nArguments\n\nhistory: Vector of messages\nactive_agent: Current active agent\nio: IO stream for printing messages\nchecks: Vector of termination checks\n\nReturns\n\nUnion{AbstractAgent, Nothing}: Updated active agent (nothing if terminated)\n\nNotes\n\nIgnores PrivateMessage visibility for all checks\nPrints termination messages to io when triggered\n\n\n\n\n\n","category":"method"},{"location":"api/#SwarmAgents.scrub_agent_name-Tuple{AbstractAgent}","page":"API","title":"SwarmAgents.scrub_agent_name","text":"scrub_agent_name(agent::AbstractAgent)\n\nClean up agent name for display.\n\n\n\n\n\n","category":"method"},{"location":"api/#SwarmAgents.tool_output-Tuple{Any}","page":"API","title":"SwarmAgents.tool_output","text":"tool_output(output::Any)\n\nConvert tool output to string format. This function is used to convert any tool output into a string representation that can be used in tool messages.\n\nBehavior\n\nThe function handles three cases in order of precedence:\n\nAbstractString input: returns the string directly\nStruct with :output property: returns the output property value as string\nOther types: converts to string using show method\n\nCustomization\n\nUsers can customize how their tool outputs are converted to strings in two ways:\n\nDefine an :output property in your struct:\n\nstruct MyToolOutput\n    output::String  # This will be used automatically\n    other_data::Any\nend\n\nDefine a custom tool_output method for your type:\n\nstruct MyCustomOutput\n    data::Any\nend\n\n# Custom conversion method\nSwarmAgents.tool_output(x::MyCustomOutput) = \"Processed: $(x.data)\"\n\nExamples\n\n# String passthrough\ntool_output(\"hello\")  # returns \"hello\"\n\n# Struct with output property\nstruct ResultWithOutput\n    output::String\n    details::Dict\nend\nresult = ResultWithOutput(\"computation done\", Dict(\"time\" => 0.5))\ntool_output(result)  # returns \"computation done\"\n\n# Custom tool_output method\nstruct CustomResult\n    value::Int\nend\nSwarmAgents.tool_output(x::CustomResult) = \"Result: $(x.value)\"\ntool_output(CustomResult(42))  # returns \"Result: 42\"\n\n# Fallback to show method\ntool_output([1, 2, 3])  # returns \"[1, 2, 3]\"\n\nSee also: handle_tool_calls!\n\n\n\n\n\n","category":"method"},{"location":"api/#SwarmAgents.transfer_agent-Tuple{String, String}","page":"API","title":"SwarmAgents.transfer_agent","text":"transfer_agent(target_agent_name::String, handover_message::String) -> AgentRef\n\nGeneric transfer function that creates an AgentRef for the specified target agent. This function supports introspection via PT.getargnames and PT.getargtypes.\n\nArguments\n\ntarget_agent_name::String: Name of the target agent to transfer to\nhandover_message::String: Explanation for why the transfer is needed\n\nReturns\n\nAgentRef: Reference to the target agent\n\nExample\n\n# Transfer to \"Support Agent\" with explanation\nnew_agent = transfer_agent(\"Support Agent\", \"Customer needs technical assistance\")\n\n\n\n\n\n","category":"method"},{"location":"api/#SwarmAgents.update_system_message!-Union{Tuple{T}, Tuple{AbstractVector{T}, Union{Nothing, Agent}}} where T<:PromptingTools.AbstractMessage","page":"API","title":"SwarmAgents.update_system_message!","text":"update_system_message!(history::AbstractVector{<:PT.AbstractMessage}, active_agent::Union{Agent, Nothing})\n\nUpdate the system message in the history with the active agent's instructions.\n\n\n\n\n\n","category":"method"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = SwarmAgents","category":"page"},{"location":"#SwarmAgents.jl","page":"Home","title":"SwarmAgents.jl","text":"","category":"section"},{"location":"#Experimental-Package","page":"Home","title":"⚠️ Experimental Package ⚠️","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"WARNING: SwarmAgents.jl is currently in an experimental stage and is under active development. Features, APIs, and functionalities may change without notice. Use at your own risk.","category":"page"},{"location":"#Overview","page":"Home","title":"Overview","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"SwarmAgents.jl is a very opinionated translation of OpenAI's Swarm package. This Julia implementation leverages PromptingTools.jl to enable support for multiple LLM providers and tool calling functionalities.","category":"page"},{"location":"#Key-Features","page":"Home","title":"Key Features","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Integration with various LLM providers through PromptingTools.jl.\nEnhanced tool calling capabilities.\nA flexible and extensible framework for Multi-Agent systems.","category":"page"},{"location":"#Getting-Started","page":"Home","title":"Getting Started","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"You need to have API keys for a supported LLM provider (eg, OPENAI_API_KEY in your environment variables). See PromptingTools.jl for more details.\nInstall the package:","category":"page"},{"location":"","page":"Home","title":"Home","text":"using Pkg\nPkg.add(; url = \"https://github.com/svilupp/SwarmAgents.jl\")","category":"page"},{"location":"#Key-Concepts","page":"Home","title":"Key Concepts","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This implementation mostly follows the OpenAI Swarm package. It might be helpful to read the original cookbook on orchestrating agents.","category":"page"},{"location":"#Routines","page":"Home","title":"Routines","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"A routine is a set of instructions for an AI agent to follow, like a recipe.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Example: A customer service routine","category":"page"},{"location":"","page":"Home","title":"Home","text":"Understand the problem\nSuggest a solution or transfer to a specialized agent\nOffer a refund if needed","category":"page"},{"location":"#Handoffs","page":"Home","title":"Handoffs","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"A handoff occurs when one AI agent passes the conversation to another specialized agent.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Example: Customer support system","category":"page"},{"location":"","page":"Home","title":"Home","text":"Triage Agent → directs to appropriate department\nSales Agent ← handles purchases\nRepair Agent ← manages product issues","category":"page"},{"location":"","page":"Home","title":"Home","text":"Handoffs allow seamless transitions between different expertise areas, enhancing the overall interaction.","category":"page"},{"location":"#Flow-Rules-and-Tool-Control","page":"Home","title":"Flow Rules and Tool Control","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Flow rules control how tools are executed in your agent system. They determine which tools are available at any given time and in what order they should be executed.","category":"page"},{"location":"#Flow-Rule-Types","page":"Home","title":"Flow Rule Types","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"SwarmAgents supports different types of flow rules that inherit from AbstractToolFlowRules:","category":"page"},{"location":"","page":"Home","title":"Home","text":"FixedOrder: Controls tool execution order, allowing you to specify a sequence of tools to be executed\nFixedPrerequisites: Enforces tool prerequisites, ensuring tools are only available after their prerequisites are met","category":"page"},{"location":"","page":"Home","title":"Home","text":"Both FixedOrder and FixedPrerequisites are subtypes of AbstractToolFlowRules, providing consistent behavior for tool filtering and execution control.","category":"page"},{"location":"#Tool-Execution-Order","page":"Home","title":"Tool Execution Order","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"You can control tool execution using either FixedOrder or FixedPrerequisites:","category":"page"},{"location":"","page":"Home","title":"Home","text":"# Make a single tool always available\nagent = Agent(name=\"MyAgent\", instructions=\"Test agent\")\nadd_tools!(agent, my_tool)\nsession = Session(agent)\nadd_rules!(session, FixedOrder(string(my_tool.name)))  # Single tool wrapped in FixedOrder\n\n# Control execution order of multiple tools\nrules = [FixedOrder([\"tool1\", \"tool2\"]), FixedOrder([\"tool3\", \"tool4\"])]\nadd_rules!(session, rules)  # Pass vector of rules directly","category":"page"},{"location":"#Tool-Filtering-and-Error-Handling","page":"Home","title":"Tool Filtering and Error Handling","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The get_allowed_tools function determines which tools are available based on your flow rules and ensures tools exist in the agent's tool map. If a requested tool is not found, a ToolNotFoundError will be raised:","category":"page"},{"location":"","page":"Home","title":"Home","text":"# Tools must exist in agent's tool_map\nresponse = run_full_turn(agent, messages, session)\n# If a tool is not found, ToolNotFoundError is raised","category":"page"},{"location":"#Tool-Output-Handling","page":"Home","title":"Tool Output Handling","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Tools can return any arbitrary struct as output. The system processes tool output in this order:","category":"page"},{"location":"","page":"Home","title":"Home","text":"If output is an AbstractString, use it directly\nLook for the :output property if available\nUse the show method for any other type","category":"page"},{"location":"","page":"Home","title":"Home","text":"To customize output handling for your structs, either:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Define an :output property that returns an AbstractString\nImplement a custom show method for your type","category":"page"},{"location":"","page":"Home","title":"Home","text":"Example:","category":"page"},{"location":"","page":"Home","title":"Home","text":"struct CustomTool\n    output::String\nend\n\n# Will automatically use the output property\nmy_tool = CustomTool(\"Hello\")\n\n# Or implement show method\nstruct AnotherTool\n    data::Any\nend\nBase.show(io::IO, t::AnotherTool) = print(io, \"Tool output: $(t.data)\")","category":"page"},{"location":"#Tool-Availability-and-Deduplication","page":"Home","title":"Tool Availability and Deduplication","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Tools are filtered using get_allowed_tools, which:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Ensures tools exist in agent's toolmap (alltools argument)\nRemoves duplicates while preserving order\nApplies flow rule constraints","category":"page"},{"location":"","page":"Home","title":"Home","text":"# Get allowed tools based on rules and history\nallowed_tools = get_allowed_tools(session.rules, used_tools, all_tools)\n\n# Note: get_allowed_tools always deduplicates tools to ensure each tool\n# appears only once in the final sequence","category":"page"},{"location":"","page":"Home","title":"Home","text":"If no rules are present, all agent tools are available (passthrough behavior).","category":"page"},{"location":"#Usage","page":"Home","title":"Usage","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"using Swarm\n\n## Define agents and their tools\n# Instructions are the routines\nenglish_agent = Agent(name = \"English Agent\",\n    instructions = \"You only speak English.\")\nspanish_agent = Agent(name = \"Spanish Agent\",\n    instructions = \"You only speak Spanish.\")\n\n# Below are the handoffs\ntransfer_to_spanish_agent() = spanish_agent\nadd_tools!(english_agent, transfer_to_spanish_agent)\n\ntransfer_to_english_agent() = english_agent\nadd_tools!(spanish_agent, transfer_to_english_agent)\n\n# Initialize a session to hold the state and pick the initial agent\nsess = Session(english_agent)\n\n# Run a full turn until tools are depleted\nrun_full_turn!(sess, \"Hola. ¿Como estás?\")\n\n# You can run repeated turns to continue the session\nrun_full_turn!(sess, \"What do you mean?\")","category":"page"},{"location":"","page":"Home","title":"Home","text":">> User: Hola. ¿Como estás?\n\n>> Tool Request: transfer_to_spanish_agent, args: Dict{Symbol, Any}()\n>> Tool Output: {\"assistant\":\"Spanish Agent\"}\n>> Assistant: ¡Hola! Estoy bien, gracias. ¿Y tú?\n\n>> User: What do you mean?\n\n>> Tool Request: transfer_to_english_agent, args: Dict{Symbol, Any}()\n>> Tool Output: {\"assistant\":\"English Agent\"}\n>> Assistant: You were speaking in Spanish, so I transferred you to a Spanish-speaking agent. How can I assist you in English today?","category":"page"},{"location":"","page":"Home","title":"Home","text":"See folder examples/ for more examples.","category":"page"}]
}
